# 我的前端自学指南

本文档记录我在自学前端的过程中，对前端的理解和感悟, 知识体系搭建的过程，以及相关学习资源的收录。

[toc]

## Prerequisites

1. 尊重编程，尊重你的工作。如果你的出发点不是热爱，那么请至少对你的工作保持一份最基本的尊重。
2. 切记不要只看不动手，`实践实践实践`，即便是最简单的知识点，也要动手去做，不要眼高手低。
3. 不要盲目的学习和写代码，要多思考总结，建立自己的知识体系，先建立枝干，再填充细节，不要迷失在细节的海洋里。
4. 合理安排你的时间和精力，三天打鱼两天晒网和一天学十几个小时都是不可取的。保持一份平常心，一步一个脚印的前进。生活除了编程外，还有很多其他美好的东西值得你去体验。

## HTML

### 1. 熟悉 HTML 基本知识

我推荐使用`MDN`来完成入门学习

- [Introduction to HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML)
- [Getting Started with HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started)
- [What's in the head? Metadata in HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/The_head_metadata_in_HTML)
- [HTML text fundamentals](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/HTML_text_fundamentals)
- [Creating hyperlinks](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Creating_hyperlinks)
- [Advanced text formatting](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Advanced_text_formatting)
- [Document and website structure](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Document_and_website_structure)
- [Debugging HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Debugging_HTML)

基础练习资源：

- [freecodecamp HTML Basic](https://www.freecodecamp.org/learn/responsive-web-design/)

### 2. 学习多媒体标签和嵌入式标签

- [Multimedia and embedding](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding)
- [Images in HTML](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Images_in_HTML)
- [Video and audio content](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Video_and_audio_content)
- [From object to iframe: other embedding techonologies](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Other_embedding_technologies)
- [Adding vector graphics to the web](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Adding_vector_graphics_to_the_Web)
- [Responsive images](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)

### 3. 表格

- [HTML Table basics](https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Basics)
- [HTML table advanced features and accessiblity](https://developer.mozilla.org/en-US/docs/Learn/HTML/Tables/Advanced)

### 4. 表单

- [web forms: working with user data](https://developer.mozilla.org/en-US/docs/Learn/Forms)

### 5. 语义化和最佳实践

要懂得如何使用合适的标签和合理的层次嵌套写出高效简洁的页面框架，这个阶段需要进行大量的实践和思考

- [HTML Best practices](https://www.freecodecamp.org/news/html-best-practices/)

### 6. 练习资源

- [freecodecamp responsive design](https://www.freecodecamp.org/learn/responsive-web-design/)

## CSS

### 1. CSS 基础入门

- [CSS first steps](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps)
- [What is CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/What_is_CSS)
- [Getting started with CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/Getting_started)
- [How CSS is structured](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_is_structured)
- [How CSS works](https://developer.mozilla.org/en-US/docs/Learn/CSS/First_steps/How_CSS_works)

### 2. CSS 核心知识

- [核心知识概览](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks)
- [Cascade and inheritance](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Cascade_and_inheritance)
- [CSS Selectors](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Selectors)
- [The box model](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/The_box_model)
- [Backgrounds and borders](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Backgrounds_and_borders)
- [Handing different text directions](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Handling_different_text_directions)
- [Overflowing content](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Overflowing_content)
- [Sizing items in CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Sizing_items_in_CSS)
- [Images, media, and form elements](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Images_media_form_elements)
- [Styling Tables](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Styling_tables)
- [Debugging CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Debugging_CSS)
- [Organizing CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/Building_blocks/Organizing)

### 3. Styling text

- [Styling text overview](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text)
- [Fundamental text and font styling](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals)
- [Styling lists](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_lists)
- [Styling links](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Styling_links)
- [Web fonts](https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Web_fonts)

### 4. CSS Layout

- [Layout overview](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout)
- [Introduction to CSS layout](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Introduction)
- [Normal flow](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Normal_Flow)
- [Flex box](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox)
- [Grids](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids)
- [Floats](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats)
- [Positioning](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Positioning)
- [Multiple-column Layout](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Multiple-column_Layout)
- [Responsive Design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [Responsive Design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [Beginner's guide to media queries](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Media_queries)
- [Legacy Layout Methods](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Legacy_Layout_Methods)
- [Supporting Older Browsers](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Supporting_Older_Browsers)
- [Fundamental Layout Comprehension](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Fundamental_Layout_Comprehension)

### 5. CSS methodologies(方法论)

掌握常见的 CSS 方法论和工程化工具，能够写出`简洁`,`可复用`,`可维护`,`兼容性好`的 CSS

**BEM**

- [BEM-Block Element Modifier](http://getbem.com/introduction/)

**OOCSS**

**SASS**

**postCSS**

**LESS**

### 6. CSS 兼容

**CSS 兼容综述**

CSS 兼容从兼容场景来看可以分为两部分：`跨浏览器兼容` 和 `浏览器向下兼容`

- [Browser Compatibility](https://www.codecademy.com/article/f1-u5-browser-compatibility)
- [Supporting Older Browsers](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Supporting_Older_Browsers)

**兼容策略**

CSS 兼容策略主流上有两种：`progressive enhancement` (渐进式增强) 和 `graceful degradation` (优雅下降)

- [Understanding CSS Fallback Behavior](https://ageek.dev/css-fallback-behavior)

**fallback 机制**

CSS 提供了一种 fallback 机制，指的是当浏览器遇到它不支持的 CSS 属性或者非法的属性值时，浏览器不会报错，而是会直接忽略掉这个属性。

利用 CSS 的`Cascade`和这种机制可以用来实现 CSS 兼容，该机制从策略分类上属于`graceful degradation`

下面列举一些使用 fallback 机制来完成 CSS 兼容的例子：

下面这段代码在 `.red-box` 类选择器中同时声明了两行用来定义背景颜色的代码。

其中 `background-color: red` 写在 `background-color: var(--red-color)` 前面。

当浏览器支持 `var` 函数时，因为 `Cascade`，`background-color: var(--red-color)` 会覆盖 `background-color: red`。

当浏览器不支持 `var` 函数时，浏览器会直接忽略 `background-color: var(--red-color)`, 从而 `background-color: red` 会生效，实现 `graceful degradation`

```css
:root {
  --red-color: red;
}
.red-box {
  background-color: red;
  background-color: var(--red-color);
}
```

另一个例子就是常见的字体栈( `font stack` ):

```css
// 下面的例子来自于知乎PC端网页的字体设置
body {
  font-family: -apple-system, BlinkMacSystemFont, Helvetica Neue, PingFang SC,
    Microsoft YaHei, Source Han Sans SC, Noto Sans CJK SC, WenQuanYi Micro Hei,
    sans-serif;
}
```

### 7. CSS Patterns

在写 CSS 时，有一些解决某些特定问题的通用解法和最佳实践，这些可以称之为 `Patterns` ，学习和运用这些 `Patterns` 可以节省我们大量时间和精力。

- [The beginner's Guide to Web Design Patterns](https://blog.hubspot.com/website/design-patterns)
- [Patterns: a collection of code snippets to help you optimize your web projects](https://web.dev/patterns/)

### 8. 练习资源

- [freecodecamp](https://www.freecodecamp.org/learn/responsive-web-design/)
- [Brad Traversy's 50 projects 50 days](https://www.udemy.com/course/50-projects-50-days)
- [Jonas Schmedtmann's Advanced CSS and Sass](https://www.udemy.com/course/advanced-css-and-sass)

## JavaScript

### 1. 入门基础

- [JavaScript First steps](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps)
- [What is JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_is_JavaScript)
- [A first splash into javascript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/A_first_splash)
- [What went wrong? Troubleshooting JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/What_went_wrong)
- [Storing the information you need: Variables](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Variables)
- [Basic math in JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Math)
- [Handling text: strings in JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Strings)
- [Useful string methods](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Useful_string_methods)
- [Arrays](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Arrays)

基础知识练习：

- [freecodecamp JavaScript](https://www.freecodecamp.org/learn/javascript-algorithms-and-data-structures/)
- [Silly story_generator](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Silly_story_generator)

### 2. 核心知识

核心知识概览：

- [JavaScript building blocks](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks)

条件判断：

- [Making decisions in your code](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/conditionals)

循环：

- [Looping code](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Looping_code)

函数：

- [Functions: reusable blocks of code](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Functions)
- [Build your own function](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Build_your_own_function)
- [Function return values](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Return_values)

`this` :

- [Understanding JavaScript Bind()](https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/#top)

### 3. 对象

对象概要介绍：

- [Introducing JavaScript objects](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects)
- [JavaScript ojbect basics](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics)

原型 `prototype` :

- [Object prototypes](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes)
- [Object-oriented programming](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)

类 `class` :

- [Classes in JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Classes_in_JavaScript)

`JSON` :

- [Working with JSON](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON)

练习资源：

- [Object building practice](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_building_practice)
- [Adding features to our bouncing balls demo](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Adding_bouncing_balls_features)

### 4. 异步编程

初步了解异步编程的基本概念：

- [Asynchronous JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)
- [Introducing asynchoronous JavaScript](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing)

在初步知道异步编程的概念后，下一步要了解浏览器的事件循环(`Event Loop`)，这有助于理解 JavaScript 是怎么在浏览器中执行的，在面对异步代码的时候，脑海中有一个清晰的异步模型，可以帮助你分析代码的执行顺序，从而提高代码质量，减少 BUG：

下面这个视频对 `Event Loop` 讲的很好，是学习 `Event Loop` 很好的入门材料，但是他没有讲到 `Task`(宏任务) 和 `micro task`(微任务) ：

- [What the heck is the eventloop anyway](https://www.youtube.com/watch?v=8aGhZQkoFbQ)

下面这篇文章对宏任务和微任务讲解的很不错，文章不止讲了异步任务队列，还详细介绍了异步任务队列其实有 3 种：`Task queue`, `Render queue` 和 `Microtask queue` 在执行顺序上是：`Microtask queue`->`Render queue`->`Task queue`

- [How does JavaScript work](https://bravelab.io/blog/how-does-javascript-work/)

如果看了上面这篇文章还是对异步模型的具体运转不太了解，那么下面这篇文章制作了几个演示程序，一步一步的演示几个异步队列是如何运作的：

- [tasks microtasks queues and schedules](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

在了解完 `Event Loop` 后，接下来学习现代 JavaScript 异步编程的基石 `Promise` :

- [How to use promises](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Promises)
- [How to implement a promise-based API](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Implementing_a_promise-based_API)

`Web workers` :

- [Introducing workers](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing_workers)

### 5. JavaScript 高阶知识

`Scope` :

闭包 `Closure`:

以前我一直不知道闭包是用来干什么的，对什么是闭包也是一知半解。其实，每个概念都有它存在的理由。

在 JavaScript 中是没有传统面向对象语言如 Java 中 `public` 和 `private` 的概念的，所以 JavaScript 中的对象对外是完全开放的，所有人都能随意读取和使用它的属性和方法。

但是这对于封装和抽象是很不友好的。因此，为了实现抽象和封装功能，有必要引入一种方法，而在我的理解中，这种方法就是 `Closure` 。

基于 `Scope` 的知识，在 JavaScript 中除了 `Global` 域外，只有函数具有作用域，并且函数的作用域从外面是访问不到的，这就具有天然的隐私性，可以用来保存私有数据和私有方法。但问题在于，函数的 `Scope` 在函数被执行完毕后就会被销毁，里面保存的数据和方法就都没了。

那么有没有一种方法可以保证函数在执行完毕后它的 `Scope` 还能保存在内存中不被回收呢?

有的，这就是 `Closure`。我把 `Closure` 理解为函数执行完毕后返回给外面的一个接口，或者说一个 `handler`。

因为有这个接口的存在，`GC`(垃圾回收器)知道这个函数的 `Scope` 还在被使用，所以在函数执行完后不会对它的 `Scope` 进行回收。

如果你在网上搜索什么是闭包？一般都会得到一个回答：`闭包是指有权访问另一个函数作用域中的变量的函数。`

我刚开始看到这句话的时候，对它的理解是只有返回函数的函数才是闭包。那么，是不是如果一个函数返回的这个`接口`不是函数，就没有办法访问`Scope`中保存的数据和方法了呢？如果我前面的理解是对的话，那么当然不是的，比如下面这个例子：

```js
function closure() {
  // 私有变量
  let private_variable = "I am a private varaible"
  // 公共方法
  const get = () => {
    return private_variable
  }
  const set = (newVal) => {
    private_variable = newVal
  }

  // 返回该函数 Scope 的接口
  return { set, get }
}

let obj = closure()

console.log(obj.get()) // "I am a private varaible"

obj.set("Hello World")

console.log(obj.get()) // "Hello World"
```

从上面这段代码我们可以看到，`closure` 函数没有返回一个函数，而是返回了一个对象，但通过该对象依然能访问到 `closure` 函数。你能说这不是闭包吗？

我们接着在上面的例子上做一点小修改：

```js
function closure() {
  // 私有变量
  let private_variable = "I am a private varaible"
  // 公共方法
  const get = () => {
    return private_variable
  }
  const set = (newVal) => {
    private_variable = newVal
  }

  // 返回该函数 Scope 的接口
  return [get, set]
}

let obj = closure()

console.log(obj[0]()) // "I am a private varaible"

obj[1]("Hello World")

console.log(obj[0]()) // "Hello World"
```

这段代码中，我们返回的是一个数组，同样可以看到`closure` 函数的 `Scope` 被保存了。

从上面的分析可以看到，闭包的形成本质在于 `Scope` 的串联，而不在于函数返回值是什么。

因此，只要返回的数据结构中有在该函数 `Scope` 中定义的函数，那么就会形成 `Scope` 的串联。

如果你只返回非函数变量，那么就没有办法形成`Scope` 的串联。

综上，我把`Closure`闭包理解为 `私有数据` + `对外的公共接口`。

### 5. JavaScript 书籍推荐

- [You don't know JS yet](https://github.com/getify/You-Dont-Know-JS)
- [Understanding ECMAScript 6: The Definitive Guide for JavaScript Developers](https://leanpub.com/understandinges6/read/#leanpub-auto-introduction)

### 3. 熟练使用 `ES6`

### 4. 使用 `TypeScirpt`

#### 4.1 入门，花个`10-20`分钟学习基本用法，然后开始上手，在实践中学习

**Resources List:**

- [Documentation - TypeScript for JavaScript Programmers](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
- [Documentation - TypeScript Tooling in 5 minutes](https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html)

#### 4.2 学习如何将 `TypeScript` 在项目中使用

**Resources List:**

- [How to Set Up a Node Project With TypeScript](https://www.digitalocean.com/community/tutorials/setting-up-a-node-project-with-typescript)
- [TypeScript tsconfig tutorial](https://www.youtube.com/watch?v=dPgAXFcFHCM)

#### 4.3 学习如何配置 `tsconfig.json`

**Resources List:**

- [TSconfig Reference](https://www.typescriptlang.org/tsconfig)
- [TypeScript 配置文件该怎么写？](https://zhuanlan.zhihu.com/p/197425558)

#### 4.4 如何在编译 `ts` 文件时一起将其他 `assets` 拷贝到 `output` 目录下

**Resources List:**

- [tsc: How to copy non-TypeScript files when building](https://vccolombo.github.io/blog/tsc-how-to-copy-non-typescript-files-when-building/)

## 框架

### 1. 掌握框架的组成部分

了解框架的各个 `组成部分`，懂得每个部分要解决的 `问题` 是什么？进而发现前端框架的`共通点`，在这个过程中可以与 `原生开发` 进行对比学习，了解 `原生开发基本原理` 和其 `痛点`

#### 1.1 框架的组成部分

现阶段主要以 `React` 为研究对象，后续会加入对 `Vue` 的学习研究

**Resources List:**

- [Framework main features](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features)

#### 1.2 `DOM` 操作

在不使用框架的年代，浏览器提供的 `DOM API` 使用起来超级繁琐。
虽然 `JQuery` 的出现简化了很多操作，且磨平了各大浏览器之间的差异。
但是，还是很麻烦。
直到 `MVVM` 这一类框架的出现，直接把`DOM`给 `屏蔽` 了，大大提高了开发效率。
为了更好的使用框架，因此，很有必要研究框架是如何做到 `屏蔽DOM` 的，其背后做了哪些牺牲？在写 `UI` 的过程中，有哪些方面是开发者可以进行优化的？

**Resources List:**

- [What is Virtual DOM? And Why is it faster?](https://dev.to/karthikraja34/what-is-virtual-dom-and-why-is-it-faster-14p9)

#### 1.3 `Event System`

在我的理解中，前端很多代码的存在都是为了处理交互，而交互基于事件系统。
因此，学习了解事件系统有助于写出更优雅的代码。

`React`并没有直接使用浏览器提供的原生 `Event System`, 而是使用了 `SyntheticEvent`, 其目的主要是为了兼容性，保持 `Consistency`。
我猜测其实现应该和 `JQuery` 对于 `DOM` 的封装类似，在原生事件上进行了一层封装，从而保持一致性。

**Resources List:**

- [Handling Events](https://reactjs.org/docs/handling-events.html)
- [SyntheticEvent](https://reactjs.org/docs/events.html)
- [Handling React Events](https://www.knowledgehut.com/blog/web-development/handling-react-events-guide)

#### 1.4 `State`

`State`的管理是各大框架面临的一个 `Major Issue`。
当应用规模较小，需要管理的 `State` 较少且 `Data flow` 比较简单时，完全可以使用框架提供的功能实现([])。
比如在 `React` 中，通过 `State` 和 `Prop` 应该就能完成简单功能的开发，稍微复杂一点也可以由 `Context` 实现。

但是当应用规模和复杂度较大时（我也没碰过大型项目啊，淦！），上述方法会出现问题（啥问题？我不理解，这些话我都是听别人说的，没有实际体验都是瞎扯淡）。
因此一些状态管理工具就推出了，比如 `React` 中的 `Redux` `Mobx` `Recoil`, `Vue` 中的 `Vuex`。

虽然我不懂，但感觉好厉害的样子。不过学习这些状态管理工具背后的 `设计思想` 应该对于写出优雅的程序有帮助吧！（应该吧？）

**Resources List:**

- [Getting Started with Redux](https://redux.js.org/introduction/getting-started)

#### 1.5 生命周期

在组件化的今天，组件的生命周期的出现是一件很自然的事情。
组件的生命周期是几个不同的阶段，比如组件的创建，初始化，安装，状态更新，卸载等。
日常开发中我们所使用的生命周期其实是框架提供的生命周期钩子函数，这些钩子函数本身并不是生命周期阶段，而是阶段中间的一个点。比如：
beforeCreate -> `组件创建` -> created -> beforeInit -> `组件初始化` -> inited -> beforeUpdate `状态更新` -> updated
上述举例并不完全，并且不同的框架对于生命周期的定义也有所不同。但是大致的流程是相似的，一通百通。
不过好像听说在 `React` 中，`Hooks` 的出现把生命周期函数干翻了，也不知道是真是假，后续再研究一下。

```

```
